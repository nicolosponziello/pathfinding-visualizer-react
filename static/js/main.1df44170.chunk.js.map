{"version":3,"sources":["components/Node/node_data.ts","constants.ts","components/Node/node.component.tsx","utils/index.ts","algorithms/common.ts","algorithms/index.ts","algorithms/astar-heuristics.ts","algorithms/maze-generation/MazeGenerationAlgorithms.ts","components/Header/header.component.tsx","algorithms/maze-generation/tree-generator.ts","algorithms/maze-generation/dfs-generator.ts","algorithms/maze-generation/sidewinder-generator.ts","components/Grid/Grid.component.tsx","algorithms/dfs.ts","algorithms/dijkstra.ts","algorithms/bfs.ts","algorithms/astar.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["CellType","GRID_WIDTH","window","innerWidth","GRID_HEIGHT","innerHeight","H_CELLS_NUM","V_CELLS_NUM","Node","props","cssClass","type","EMPTY","START","END","WALL","VISITED","SHORTEST_PATH","onMouseDown","mouseDown","onMouseEnter","mouseEnter","className","style","width","height","randomInteger","min","max","Math","floor","random","gridDirections","r","c","getAdjNodes","grid","element","adj","Array","push","length","filter","n","compareNodes","a","b","ALGORITHMS","Euristic","MazeGenAlgorithms","calculateHeuristic","start","end","DIAGONAL","abs","diagonal","EUCLIDEAN","sqrt","pow","euclidean","MANHATTAN","manhattan","Header","useState","wallNum","setWallNum","BFS","algoSelected","setAlgo","euristic","setEuristic","BACKTRACKING","mazeAlgo","setMazeAlgo","value","onChange","ev","parseInt","target","onClick","randomWalls","defaultValue","Object","values","isNaN","map","generateMaze","onStart","disabled","ASTAR","e","resetAnimation","resetAll","generateIMG","_","require","directions","dfsMazeGenerator","visited","i","el","j","row","col","stack","current","undefined","pop","neighbours","forEach","dir","coord","neighbour","sample","Grid","generateEmptyGrid","setGrid","startCoord","setStartCoord","endCoord","setEndCoord","isDraggingStart","setIsDraggingStart","isDraggingEnd","setIsDraggingEnd","isDraggingWall","setIsDraggingWall","isAnimating","setIsAnimating","algoTime","setAlgoTime","addEventListener","g","produce","copy","html2canvas","document","querySelector","then","canvas","toBlob","link","createElement","href","URL","createObjectURL","download","body","appendChild","click","removeChild","console","log","algo","res","orderOfVisit","shortestPath","startTime","Date","now","Number","DFS","parents","found","tmp","currentNode","some","adjs","reverse","iterativeDFS","DIJKSTRA","nodesToVisit","orderOfExamination","dist","tmp2","Infinity","sort","closest","shift","candidate","neighbor","dijkstra","queue","tmpDist","tmpVis","openList","closedList","nodes","f","h","parent","neigbor","tentative_g_score","AStar","toAnimate","setTimeout","animateResult","amount","randX","randY","SIDEWINDER","runSet","randomCell","sidewinderMazeGenerator","TREE","newRow","newCol","treeMazeGenerator","id","display","gridTemplateColumns","toFixed","version","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.1df44170.chunk.js","sourcesContent":["export type GridNode = {\n  row: number;\n  col: number;\n  type: CellType;\n};\n\nexport enum CellType {\n  WALL,\n  EMPTY,\n  START,\n  END,\n  VISITED,\n  SHORTEST_PATH,\n}\n\nexport type Coordinate = {\n  r: number;\n  c: number;\n};\n\nexport type AlgorithmResult = {\n  orderOfVisit: Array<Coordinate>;\n  shortestPath: Array<Coordinate>;\n};","export const SQUARE_WIDTH = 30;\nexport const SQUARE_HEIGHT = 30;\n\nexport const GRID_WIDTH = window.innerWidth * 0.9;\nexport const GRID_HEIGHT = window.innerHeight * 0.7;\n\nexport const H_CELLS_NUM = GRID_WIDTH / SQUARE_WIDTH;\nexport const V_CELLS_NUM = GRID_HEIGHT / SQUARE_HEIGHT;\n","import React from \"react\";\nimport { SQUARE_WIDTH, SQUARE_HEIGHT } from \"../../constants\";\nimport \"./node.styles.css\";\nimport { CellType } from \"./node_data\";\ninterface Props {\n  row: number;\n  col: number;\n  type: CellType;\n  mouseDown: Function;\n  mouseEnter: Function;\n}\n\nconst Node = (props: Props) => {\n  var cssClass = \"\";\n  switch (props.type) {\n    case CellType.EMPTY:\n      cssClass = \"empty\";\n      break;\n    case CellType.START:\n      cssClass = \"start\";\n      break;\n    case CellType.END:\n      cssClass = \"end\";\n      break;\n    case CellType.WALL:\n      cssClass = \"wall\";\n      break;\n    case CellType.VISITED:\n      cssClass = \"visited\";\n      break;\n    case CellType.SHORTEST_PATH:\n      cssClass = \"shortestPath\";\n      break;\n  }\n  return (\n    <div\n      onMouseDown={() => props.mouseDown()}\n      onMouseEnter={() => props.mouseEnter()}\n      className={`node ${cssClass}`}\n      style={{\n        width: SQUARE_WIDTH,\n        height: SQUARE_HEIGHT,\n      }}\n    />\n  );\n};\n\nexport default Node;\n","export function randomInteger(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function randomEnum<T>(en: T): T[keyof T] {\n  let values = (Object.keys(en)\n    .map((n) => Number.parseInt(n))\n    .filter((n) => !Number.isNaN(n)) as unknown) as T[keyof T][];\n  let randomIndex = randomInteger(0, values.length);\n  return values[randomIndex];\n}\n\nexport const gridDirections = [\n  { r: +1, c: 0 }, //bottom\n  { r: -1, c: 0 }, //top\n  { r: 0, c: -1 }, //left\n  { r: 0, c: +1 }, //right\n];","import { CellType, Coordinate, GridNode } from \"../components/Node/node_data\";\n\nexport function getAdjNodes(\n  grid: Array<Array<GridNode>>,\n  element: Coordinate\n): Array<Coordinate> {\n  var adj = Array<Coordinate>();\n\n  if (element.r > 0) adj.push({ r: element.r - 1, c: element.c });\n  if (element.r + 1 < grid.length) adj.push({ r: element.r + 1, c: element.c });\n  if (element.c > 0) adj.push({ r: element.r, c: element.c - 1 });\n  if (element.c + 1 < grid[0].length)\n    adj.push({ r: element.r, c: element.c + 1 });\n\n  return adj.filter((n) => grid[n.r][n.c].type != CellType.WALL);\n  //.sort(() => Math.random() - 0.5);\n}\n\n\nexport const compareNodes = (a: Coordinate, b: Coordinate): boolean => {\n  return a.r === b.r && a.c === b.c;\n};","export enum ALGORITHMS {\n  BFS,\n  DFS,\n  DIJKSTRA,\n  ASTAR,\n}\n","import { Coordinate } from \"../components/Node/node_data\";\n\nconst euclidean = (start: Coordinate, end: Coordinate): number => {\n  return Math.sqrt(Math.pow(end.r - start.r, 2) + Math.pow(end.c - start.c, 2));\n};\n\nconst diagonal = (start: Coordinate, end: Coordinate): number => {\n  return Math.max(Math.abs(start.r - end.r), Math.abs(start.c - end.c));\n};\n\nconst manhattan = (start: Coordinate, end: Coordinate): number => {\n  return Math.abs(start.r - end.r) + Math.abs(start.c - end.c);\n};\n\nexport enum Euristic {\n  MANHATTAN,\n  EUCLIDEAN,\n  DIAGONAL,\n}\n\nexport const calculateHeuristic = (\n  type: Euristic,\n  start: Coordinate,\n  end: Coordinate\n): number => {\n  switch (type) {\n    case Euristic.DIAGONAL:\n      return diagonal(start, end);\n    case Euristic.EUCLIDEAN:\n      return euclidean(start, end);\n    case Euristic.MANHATTAN:\n      return manhattan(start, end);\n  }\n};\n","export enum MazeGenAlgorithms {\n  BACKTRACKING,\n  TREE,\n  SIDEWINDER,\n}\n","import React, { useState } from \"react\";\nimport { ALGORITHMS } from \"../../algorithms\";\nimport { Euristic } from \"../../algorithms/astar-heuristics\";\nimport { MazeGenAlgorithms } from \"../../algorithms/maze-generation/MazeGenerationAlgorithms\";\nimport \"./header.styles.css\";\ninterface Props {\n  onStart: Function;\n  randomWalls: Function;\n  resetAnimation: () => void;\n  resetAll: () => void;\n  generateMaze: (algo: MazeGenAlgorithms) => void;\n  generateIMG: () => void;\n}\n\nconst Header = (props: Props) => {\n  const [wallNum, setWallNum] = useState(10);\n  const [algoSelected, setAlgo] = useState<ALGORITHMS>(ALGORITHMS.BFS);\n  const [euristic, setEuristic] = useState(Euristic.MANHATTAN);\n  const [mazeAlgo, setMazeAlgo] = useState(MazeGenAlgorithms.BACKTRACKING);\n  return (\n    <>\n      <div className=\"header-bar\">\n        <span className=\"app-name\">Algorithm Pathfinding</span>\n        <label>\n          <span className=\"selector-label\">Walls: </span>\n          <input\n            className=\"input\"\n            value={wallNum}\n            type=\"number\"\n            onChange={(ev) => setWallNum(parseInt(ev.target.value))}\n          />\n        </label>\n        <button className=\"button\" onClick={() => props.randomWalls(wallNum)}>\n          Generate Walls\n        </button>\n        <select\n          className=\"select\"\n          onChange={(ev: any) => setMazeAlgo(ev.target.value)}\n          defaultValue={MazeGenAlgorithms[0]}\n        >\n          {Object.values(MazeGenAlgorithms)\n            .filter((a: any) => !isNaN(a))\n            .map((a: any) => (\n              <option key={a} value={a}>\n                {MazeGenAlgorithms[a]}\n              </option>\n            ))}\n        </select>\n        <button className=\"button\" onClick={() => props.generateMaze(mazeAlgo)}>\n          Generate Maze\n        </button>\n        <button\n          className=\"button start-btn\"\n          onClick={() => props.onStart(algoSelected, euristic)}\n        >\n          START\n        </button>\n        <div>\n          <span className=\"selector-label\">Algorithm: </span>\n          <select\n            className=\"select\"\n            onChange={(ev: any) => setAlgo(ev.target.value)}\n            defaultValue={ALGORITHMS[0]}\n          >\n            {Object.values(ALGORITHMS)\n              .filter((a: any) => !isNaN(a))\n              .map((a: any) => (\n                <option key={a} value={a}>\n                  {ALGORITHMS[a]}\n                </option>\n              ))}\n          </select>\n\n          <select\n            defaultValue={Euristic.MANHATTAN}\n            disabled={algoSelected != ALGORITHMS.ASTAR}\n            className=\"select\"\n            onChange={(ev: any) => setEuristic(ev.target.value)}\n          >\n            {Object.values(Euristic)\n              .filter((e: any) => !isNaN(e))\n              .map((e: any) => (\n                <option key={e} value={e}>\n                  {Euristic[e]}\n                </option>\n              ))}\n          </select>\n        </div>\n        <button className=\"button\" onClick={props.resetAnimation}>\n          Reset Animation\n        </button>\n        <button className=\"button\" onClick={props.resetAll}>\n          Reset All\n        </button>\n        <button className=\"button\" onClick={props.generateIMG}>\n          Save as IMG\n        </button>\n      </div>\n    </>\n  );\n};\n\nexport default Header;\n","import {\n  CellType,\n  Coordinate,\n  GridNode,\n} from \"../../components/Node/node_data\";\nimport { V_CELLS_NUM, H_CELLS_NUM } from \"../../constants\";\nvar _ = require(\"lodash\");\n\nexport function treeMazeGenerator(\n  start: Coordinate,\n  end: Coordinate\n): Array<Array<GridNode>> {\n  //generate grid\n  var grid = Array<Array<GridNode>>();\n  for (var i = 0; i < V_CELLS_NUM; i++) {\n    var el = Array<GridNode>();\n    for (var j = 0; j < H_CELLS_NUM; j++) {\n      el.push({\n        row: i,\n        col: j,\n        type: CellType.WALL,\n      });\n    }\n    grid.push(el);\n  }\n\n  for (i = 0; i < V_CELLS_NUM; i++) {\n    for (j = 0; j < H_CELLS_NUM; j++) {\n      var dir = getRandomDirection();\n      //leave a border around the screen\n      var newRow = Math.floor(\n        Math.min(V_CELLS_NUM - 1, Math.max(i + dir.r, 1))\n      );\n      var newCol = Math.floor(\n        Math.min(H_CELLS_NUM - 1, Math.max(1, j + dir.c))\n      );\n      if (\n        grid[newRow][newCol] != undefined &&\n        grid[newRow][newCol].type != CellType.START &&\n        grid[newRow][newCol].type != CellType.END\n      ) {\n        grid[newRow][newCol].type = CellType.EMPTY;\n      }\n    }\n  }\n\n  grid[start.r][start.c].type = CellType.START;\n  grid[end.r][end.c].type = CellType.END;\n\n  return grid;\n}\n\nfunction getRandomDirection(): Coordinate {\n  return _.sample([\n    { r: +1, c: 0 },\n    { r: 0, c: +1 },\n  ]);\n}\n","import {\n  CellType,\n  Coordinate,\n  GridNode,\n} from \"../../components/Node/node_data\";\nimport { V_CELLS_NUM, H_CELLS_NUM } from \"../../constants\";\nvar _ = require(\"lodash\");\n\nvar directions: Array<Coordinate> = [\n  { r: +1, c: 0 },\n  { r: -1, c: 0 },\n  { r: 0, c: +1 },\n  { r: 0, c: -1 },\n];\n\n//start at start cell\n// generate all neighbours and mark them as visited\n// open a random passage\n// the open cell is then pushed on the stack\n\nexport function dfsMazeGenerator(\n  start: Coordinate,\n  end: Coordinate\n): Array<Array<GridNode>> {\n  //generate grid\n  var grid = Array<Array<GridNode>>();\n  var visited = Array<Array<boolean>>();\n  for (var i = 0; i < V_CELLS_NUM; i++) {\n    var el = Array<GridNode>();\n    var b = Array<boolean>();\n    for (var j = 0; j < H_CELLS_NUM; j++) {\n      el.push({\n        row: i,\n        col: j,\n        type: CellType.WALL,\n      });\n      b.push(false);\n    }\n    grid.push(el);\n    visited.push(b);\n  }\n  \n\n  var stack: Array<Coordinate> = [];\n  stack.push(start);\n  var current: Coordinate = start;\n  visited[current.r][current.c] = true;\n  while (stack.length > 0) {\n    current = stack.pop()!;\n\n    if (current === undefined) break;\n\n    //check neighbours\n    var neighbours: Array<Coordinate> = [];\n    directions.forEach((dir) => {\n      if (\n        check({ r: current.r + dir.r, c: current.c + dir.c })\n      ) {\n        if(!visited[current.r+dir.r][current.c+dir.c])\n          neighbours.push({ r: current.r + dir.r, c: current.c + dir.c });\n      }\n    });\n    //randomly open a neighbour and add it to the stack\n    if(neighbours.length > 0){\n      var neighbour: Coordinate = _.sample(neighbours);\n      grid[neighbour.r][neighbour.c].type = CellType.EMPTY;\n      grid[current.r][current.c].type = CellType.EMPTY;\n      neighbours.forEach(n => visited[n.r][n.c] = true);\n      neighbours.forEach(n => {\n        if (n != neighbour)\n          stack.push(n);\n      });\n      stack.push(neighbour);\n    }\n  }\n\n  grid[start.r][start.c].type = CellType.START;\n  grid[end.r][end.c].type = CellType.END;\n\n  return grid;\n}\n\nfunction check(coord: Coordinate): boolean {\n  return (\n    coord.r > 0 &&\n    coord.r < V_CELLS_NUM - 1 &&\n    coord.c > 0 &&\n    coord.c < H_CELLS_NUM - 1\n  );\n}","import {\n  CellType,\n  Coordinate,\n  GridNode,\n} from \"../../components/Node/node_data\";\nimport { V_CELLS_NUM, H_CELLS_NUM } from \"../../constants\";\nvar _ = require(\"lodash\");\n\nexport function sidewinderMazeGenerator(\n  start: Coordinate,\n  end: Coordinate\n): Array<Array<GridNode>> {\n  //generate grid\n  var grid = Array<Array<GridNode>>();\n  for (let i = 0; i < V_CELLS_NUM; i++) {\n    var el = Array<GridNode>();\n    for (let j = 0; j < H_CELLS_NUM; j++) {\n      el.push({\n        row: i,\n        col: j,\n        type: CellType.WALL,\n      });\n    }\n    grid.push(el);\n  }\n\n  //first row is always empty\n  for (let col = 0; col < H_CELLS_NUM; col++) {\n    grid[1][col].type = CellType.EMPTY;\n  }\n\n  for (let row = 2; row < V_CELLS_NUM; row += 2) {\n    var runSet = [];\n    for (let col = 1; col < H_CELLS_NUM; col += 2)  {\n      grid[row][col].type = CellType.EMPTY;\n      runSet.push({  r: row, c: col  });\n      let carveEast = Math.random() > 0.5;\n\n      if   (carveEast && col < H_CELLS_NUM -   2)   {\n        grid[row][col   +   1].type = CellType.EMPTY;\n      }   else   {\n        let randomCell = _.sample(runSet);\n        grid[randomCell.r -   1][randomCell.c].type = CellType.EMPTY;\n        runSet = [];\n      }\n    }\n  }\n\n  grid[start.r][start.c].type = CellType.START;\n  grid[end.r][end.c].type = CellType.END;\n\n  return grid;\n}\n\nfunction isStartOrEnd(\n  i: number,\n  j: number,\n  start: Coordinate,\n  end: Coordinate\n): boolean {\n  if (i == start.c && j == start.c) {\n    return true;\n  }\n  if (i == end.r && j == end.c) {\n    return true;\n  }\n  return false;\n}\n\nfunction getRandomDirection(): Coordinate {\n  if (Math.random() >= 0.4) {\n    //north\n    return { r: +1, c: 0 };\n  } else {\n    //west\n    return { r: 0, c: +1 };\n  }\n}\n","import React, { useState } from \"react\";\nimport { H_CELLS_NUM, SQUARE_WIDTH, V_CELLS_NUM } from \"../../constants\";\nimport Node from \"../Node/node.component\";\nimport { produce } from \"immer\";\nimport {\n  GridNode,\n  CellType,\n  Coordinate,\n  AlgorithmResult,\n} from \"../Node/node_data\";\nimport dijkstra from \"../../algorithms/dijkstra\";\nimport  {iterativeDFS} from \"../../algorithms/dfs\";\nimport { randomInteger } from \"../../utils\";\nimport BFS from \"../../algorithms/bfs\";\n\nimport \"./grid.style.css\";\nimport Header from \"../Header/header.component\";\nimport AStar from \"../../algorithms/astar\";\nimport { Euristic } from \"../../algorithms/astar-heuristics\";\nimport { ALGORITHMS } from \"../../algorithms\";\nimport { treeMazeGenerator } from \"../../algorithms/maze-generation/tree-generator\";\nimport { dfsMazeGenerator } from \"../../algorithms/maze-generation/dfs-generator\";\nimport { sidewinderMazeGenerator } from \"../../algorithms/maze-generation/sidewinder-generator\";\nimport { MazeGenAlgorithms } from \"../../algorithms/maze-generation/MazeGenerationAlgorithms\";\n\n\nimport { version } from \"../../../package.json\";\nimport html2canvas from \"html2canvas\";\n\n\nconst generateEmptyGrid = () => {\n  var grid = Array<Array<GridNode>>();\n  for (var i = 0; i < V_CELLS_NUM; i++) {\n    var el = Array<GridNode>();\n    for (var j = 0; j < H_CELLS_NUM; j++) {\n      el.push({\n        row: i,\n        col: j,\n        type: CellType.EMPTY,\n      });\n    }\n    grid.push(el);\n  }\n  //set start and end\n  grid[5][5].type = CellType.START;\n  grid[grid.length - 5][grid[0].length - 5].type = CellType.END;\n  return grid;\n};\n\n\nexport const Grid = () => {\n  const [grid, setGrid] = useState(() => {\n    return generateEmptyGrid();\n  });\n  const [startCoord, setStartCoord] = useState({ r: 5, c: 5 });\n  const [endCoord, setEndCoord] = useState({\n    r: grid.length - 5,\n    c: grid[0].length - 5,\n  });\n  const [isDraggingStart, setIsDraggingStart] = useState(false);\n  const [isDraggingEnd, setIsDraggingEnd] = useState(false);\n  const [isDraggingWall, setIsDraggingWall] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [algoTime, setAlgoTime] = useState(0);\n\n  window.addEventListener('mouseup', () => {\n    setIsDraggingStart(false);\n    setIsDraggingEnd(false);\n    setIsDraggingWall(false);\n  }, false);\n\n  const resetAll = () => {\n    setGrid((g) => {\n      return produce(g, (copy) => {\n        for (var i = 0; i < copy.length; i++) {\n          for (var j = 0; j < copy[0].length; j++) {\n            if (\n              copy[i][j].type === CellType.SHORTEST_PATH ||\n              copy[i][j].type === CellType.VISITED ||\n              copy[i][j].type === CellType.WALL\n            )\n              copy[i][j].type = CellType.EMPTY;\n          }\n        }\n      });\n    });\n  };\n\n  const animateResult = (res: AlgorithmResult) => {\n    setIsAnimating(true);\n    //animate visited\n    for (let i = 0; i < res.orderOfVisit.length; i++) {\n      let toAnimate = res.orderOfVisit[i];\n      if (!toAnimate) {\n        return;\n      }\n      setTimeout(() => {\n        setGrid((g) => {\n          return produce(g, (copy) => {\n            if (\n              copy[toAnimate.r][toAnimate.c].type != CellType.END &&\n              copy[toAnimate.r][toAnimate.c].type != CellType.START\n            ) {\n              copy[toAnimate.r][toAnimate.c].type = CellType.VISITED;\n            }\n          });\n        });\n      }, 80);\n    }\n\n    //animate shortest path\n    for (let i = 0; i < res.shortestPath.length; i++) {\n      let toAnimate = res.shortestPath[i];\n      if (!toAnimate) return;\n      setTimeout(() => {\n        setGrid((g) => {\n          return produce(g, (copy) => {\n            if (\n              copy[toAnimate.r][toAnimate.c].type != CellType.END &&\n              copy[toAnimate.r][toAnimate.c].type != CellType.START\n            ) {\n              copy[toAnimate.r][toAnimate.c].type = CellType.SHORTEST_PATH;\n            }\n            //check if it is the last one\n            if (i == res.shortestPath.length - 1) {\n              setIsAnimating(false);\n            }\n          });\n        });\n      }, 80);\n    }\n  };\n\n  const start = (algo: ALGORITHMS, euristic: Euristic) => {\n    if (!isAnimating) {\n      resetAnimation();\n      var res: AlgorithmResult = { orderOfVisit: [], shortestPath: [] };\n      let startTime = Date.now();\n      switch (Number(algo)) {\n        case ALGORITHMS.DFS:\n          res = iterativeDFS(grid, startCoord, endCoord);\n          break;\n        case ALGORITHMS.DIJKSTRA:\n          res = dijkstra(grid, startCoord, endCoord);\n          break;\n        case ALGORITHMS.BFS:\n          res = BFS(grid, startCoord, endCoord);\n          break;\n        case ALGORITHMS.ASTAR:\n          res = AStar(grid, startCoord, endCoord, Number(euristic));\n      }\n      setAlgoTime(Date.now() - startTime);\n      animateResult(res);\n    }\n  };\n\n  const resetAnimation = () => {\n    setGrid((g) => {\n      return produce(g, (copy) => {\n        for (var i = 0; i < copy.length; i++) {\n          for (var j = 0; j < copy[0].length; j++) {\n            if (\n              copy[i][j].type === CellType.SHORTEST_PATH ||\n              copy[i][j].type === CellType.VISITED\n            )\n              copy[i][j].type = CellType.EMPTY;\n          }\n        }\n      });\n    });\n  };\n\n  const generateMaze = (algo: MazeGenAlgorithms): void => {\n    setGrid((g) => {\n      switch   (Number(algo))   {\n        case MazeGenAlgorithms.BACKTRACKING:\n          return dfsMazeGenerator(startCoord, endCoord);\n        case MazeGenAlgorithms.SIDEWINDER:\n          return sidewinderMazeGenerator(startCoord, endCoord);\n        case MazeGenAlgorithms.TREE:\n          return treeMazeGenerator(startCoord, endCoord);\n        default:\n          return dfsMazeGenerator(startCoord, endCoord);\n      }\n    });\n  };\n\n  const addRandomWalls = (amount: number): void => {\n    setGrid((g) => {\n      return produce(g, (copy) => {\n        let randX, randY;\n        for (let i = 0; i < amount; i++) {\n          do {\n            randX = randomInteger(0, grid.length - 1);\n            randY = randomInteger(0, grid[0].length - 1);\n          } while (copy[randX][randY].type != CellType.EMPTY);\n          copy[randX][randY].type = CellType.WALL;\n        }\n      });\n    });\n  };\n\n  const generateIMG = async () => {\n    html2canvas(document.querySelector(\"#capture\")! as HTMLElement).then(\n      (canvas) => {\n        canvas.toBlob(\n          (b) => {\n              var link = document.createElement(\"a\");\n              link.href = URL.createObjectURL(b);\n              link.download = \"screenshot\";\n\n              //Firefox requires the link to be in the body\n              document.body.appendChild(link);\n    \n              //simulate click\n              link.click();\n    \n              //remove the link when done\n              document.body.removeChild(link);\n              console.log(\"download\");\n            },\n            \"image/jpeg\",\n            1\n          );\n         \n      }\n    );\n  };\n\n  return (\n    <>\n      <Header\n        onStart={start}\n        resetAnimation={resetAnimation}\n        resetAll={resetAll}\n        randomWalls={addRandomWalls}\n        generateMaze={generateMaze}\n        generateIMG={generateIMG}\n      />\n      <span className=\"time-row\">\n        <p>Time: {algoTime}ms</p>\n      </span>\n      <div className=\"container\" id=\"capture\">\n        <div\n          className=\"grid\"\n          style={{\n            display: \"grid\",\n            gridTemplateColumns: `repeat(${H_CELLS_NUM.toFixed(\n              0\n            )}, ${SQUARE_WIDTH}px)`,\n          }}\n        >\n          {grid.map((row, i) => {\n            return row.map((col, j) => {\n              return (\n                <Node\n                  key={`${i}-${j}`}\n                  row={i}\n                  col={j}\n                  type={col.type}\n                  mouseDown={() => {\n                    if (!isAnimating) {\n                      if (col.type === CellType.START) {\n                        setIsDraggingStart(true);\n                      } else if (col.type == CellType.END) {\n                        setIsDraggingEnd(true);\n                      } else {\n                        setIsDraggingWall(true);\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            if (copy[i][j].type === CellType.EMPTY) {\n                              copy[i][j].type = CellType.WALL;\n                            } else if (copy[i][j].type === CellType.WALL) {\n                              copy[i][j].type = CellType.EMPTY;\n                            }\n                          });\n                        });\n                      }\n                    }\n                  }}\n                  mouseEnter={() => {\n                    if (!isAnimating) {\n                      if (isDraggingStart) {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            copy[startCoord.r][startCoord.c].type =\n                              CellType.EMPTY;\n                            copy[i][j].type = CellType.START;\n                          });\n                        });\n                        setStartCoord({ r: i, c: j });\n                      } else if (isDraggingEnd) {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            copy[endCoord.r][endCoord.c].type = CellType.EMPTY;\n                            copy[i][j].type = CellType.END;\n                          });\n                        });\n                        setEndCoord({ r: i, c: j });\n                      } else if (isDraggingWall) {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            if (copy[i][j].type === CellType.EMPTY) {\n                              copy[i][j].type = CellType.WALL;\n                            } else if (copy[i][j].type === CellType.WALL) {\n                              copy[i][j].type = CellType.EMPTY;\n                            }\n                          });\n                        });\n                      }\n                    }\n                  }}\n                />\n              );\n            });\n          })}\n        </div>\n      </div>\n      <div className=\"version-row\">\n        <p>Version: {version}</p>\n      </div>\n    </>\n  );\n};\n","import {\n  GridNode,\n  Coordinate,\n  AlgorithmResult,\n  CellType,\n} from \"../components/Node/node_data\";\nimport { getAdjNodes } from \"./common\";\n\nexport function iterativeDFS(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var stack = Array<Coordinate>(); //stack of visited nodes\n  var visited = Array<Coordinate>();\n  var orderOfVisit = Array<Coordinate>();\n  var parents = Array<Array<Coordinate>>();\n  var found = false;\n\n  //init parents matrix\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = Array<Coordinate>();\n    for (let j = 0; j < grid[0].length; j++) {\n      tmp.push({ r: -1, c: -1 });\n    }\n    parents.push(tmp);\n  }\n\n  var currentNode = { r: start.r, c: start.c };\n  stack.push(currentNode);\n  while (!found && stack.length) {\n    currentNode = stack.pop()!;\n    //if the node is not visited\n    orderOfVisit.push(currentNode);\n    if (!visited.some((n) => n.r === currentNode.r && n.c === currentNode.c)) {\n      visited.push(currentNode);\n    }\n    let adjs = getAdjNodes(grid, currentNode);\n    for (let i = 0; i < adjs.length; i++) {\n      if (!visited.some((n) => n.r === adjs[i].r && n.c === adjs[i].c)) {\n        parents[adjs[i].r][adjs[i].c] = currentNode;\n        stack.push(adjs[i]);\n      }\n    }\n    if (currentNode.r === end.r && currentNode.c === end.c) {\n      found = true;\n    }\n  }\n\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n\n  var shortestPath = Array<Coordinate>();\n  //build shortest path array\n  currentNode = end;\n  while (currentNode.r != start.r || currentNode.c != start.c) {\n    shortestPath.push(currentNode);\n    currentNode = parents[currentNode.r][currentNode.c];\n  }\n  shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n","import { AlgorithmResult, CellType, Coordinate, GridNode } from \"../components/Node/node_data\";\nimport { gridDirections } from \"../utils\";\n\nexport default function dijkstra(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var nodesToVisit = Array<Coordinate>();\n  var shortestPath = Array<Coordinate>();\n  var orderOfExamination = Array<Coordinate>();\n  var discoveredNodes = Array<Coordinate>();\n  var parents = Array<Array<Coordinate>>();\n  var dist = Array<Array<number>>();\n  var found = false;\n\n  //initialize dist matrix\n  for (var i = 0; i < grid.length; i++) {\n    var tmp = Array<number>();\n    var tmp2 = Array<Coordinate>();\n    for (var j = 0; j < grid[0].length; j++) {\n      tmp2.push({ r: -1, c: -1 });\n      tmp.push(Infinity);\n    }\n    parents.push(tmp2);\n    dist.push(tmp);\n  }\n  parents[start.r][start.c] = { r: 0, c: 0 };\n  dist[start.r][start.c] = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      nodesToVisit.push({ r: grid[i][j].row, c: grid[i][j].col });\n    }\n  }\n\n  var currentNode: Coordinate = { r: start.r, c: start.c };\n  while (!found && nodesToVisit.length) {\n    //sort remaining nodes by distance\n    nodesToVisit.sort((a, b) => dist[a.r][a.c] - dist[b.r][b.c]);\n    const closest = nodesToVisit.shift()!;\n\n    //hit a wall\n    if (grid[closest?.r][closest?.c].type === CellType.WALL) {\n      continue;\n    }\n\n    //trapped\n    if (dist[closest.r][closest.c] === Infinity) {\n      return {\n        orderOfVisit: orderOfExamination,\n        shortestPath: [],\n      };\n    }\n\n    //all good\n    //register visit\n    orderOfExamination.push(closest);\n    //did we find the end?\n    if (closest.r === end.r && closest.c === end.c) {\n      found = true;\n    }\n\n    //get available neighbours\n    let neighbours = [];\n    for (let i = 0; i < gridDirections.length; i++) {\n      let candidate = {       \n        r: closest.r + gridDirections[i].r,\n        c: closest.c + gridDirections[i].c,\n      };\n      if(        \n        candidate.r >= 0 &&\n        candidate.r < grid.length &&\n        candidate.c >= 0 &&\n        candidate.c < grid[0].length &&\n        !orderOfExamination.some(n => n.r === candidate.r && n.c === candidate.c)) {\n          neighbours.push(candidate);\n      }\n    }\n\n    //iterate the neighbours\n    for (const neighbor of neighbours) {\n      dist[neighbor.r][neighbor.c] = dist[closest.r][closest.c] + 1;\n      parents[neighbor.r][neighbor.c] = closest;\n    }\n\n  }\n  //calculate shortest path from end to start\n  currentNode.c = end.c;\n  currentNode.r = end.r;\n  while       (currentNode.c != start.c || currentNode.r != start.r)       {\n    shortestPath.push(currentNode);\n    currentNode = parents[currentNode.r][currentNode.c];\n  }\n  shortestPath = shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfExamination,\n    shortestPath: shortestPath,\n  };\n}","import {\n  AlgorithmResult,\n  Coordinate,\n  GridNode,\n} from \"../components/Node/node_data\";\nimport { getAdjNodes } from \"./common\";\n\nexport default function BFS(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var queue = Array<Coordinate>();\n  var orderOfVisit = Array<Coordinate>();\n  var dist = Array<Array<number>>();\n  var parents = Array<Array<Coordinate>>();\n  var visited = Array<Array<boolean>>();\n  var current;\n  var found = false;\n\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = Array<Coordinate>();\n    let tmpDist = Array<number>();\n    let tmpVis = Array<boolean>();\n    for (let j = 0; j < grid[0].length; j++) {\n      tmp.push({ r: -1, c: -1 });\n      tmpDist.push(Infinity);\n      tmpVis.push(false);\n    }\n    parents.push(tmp);\n    dist.push(tmpDist);\n    visited.push(tmpVis);\n  }\n\n  dist[start.r][start.c] = 0;\n  visited[start.r][start.c] = true;\n  queue.push(start);\n\n  while (!found && queue.length) {\n    current = queue.shift()!;\n    visited[current.r][current.c] = true;\n    if (current.r === end.r && current.c === end.c) {\n      found = true;\n    }\n    orderOfVisit.push(current);\n    let neighbours = getAdjNodes(grid, current);\n    for (const neighbor of neighbours) {\n      //if not visited yet\n      if (!visited[neighbor.r][neighbor.c]) {\n        dist[neighbor.r][neighbor.c] = dist[current.r][current.c] + 1;\n        parents[neighbor.r][neighbor.c] = current;\n        visited[neighbor.r][neighbor.c] = true;\n        queue.push(neighbor);\n\n        if (neighbor.r === end.r && neighbor.c === end.c) {\n          found = true;\n        }\n      }\n    }\n  }\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n\n  current = end;\n  var shortestPath = Array<Coordinate>();\n  while (current.r != start.r || current.c != start.c) {\n    shortestPath.push(current);\n    current = parents[current.r][current.c];\n  }\n  shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n","import {\n  AlgorithmResult,\n  Coordinate,\n  GridNode,\n} from \"../components/Node/node_data\";\nimport { calculateHeuristic, Euristic } from \"./astar-heuristics\";\nimport { compareNodes, getAdjNodes } from \"./common\";\n\nexport default function AStar(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate,\n  euristic: Euristic\n): AlgorithmResult {\n  var orderOfVisit = Array<Coordinate>();\n  var openList = Array<Coordinate>();\n  var closedList = Array<Coordinate>();\n  var found = false;\n  let nodes = Array<Array<AStarNode>>();\n  let dist = Array<Array<number>>();\n\n  //init nodes matrix\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = [];\n    let tmpDist = [];\n    for (let j = 0; j < grid[0].length; j++) {\n      tmpDist.push(Infinity);\n      tmp.push({\n        r: i,\n        c: j,\n        g: Infinity,\n        f: Infinity,\n        h: Infinity,\n        parent: null,\n      });\n    }\n    nodes.push(tmp);\n    dist.push(tmpDist);\n  }\n  \n  dist[start.r][start.c] = 0;\n\n  nodes[start.r][start.c].g = 0;\n  nodes[start.r][start.c].h = calculateHeuristic(euristic, start, end);\n  nodes[start.r][start.c].f = nodes[start.r][start.c].g + nodes[start.r][start.c].h;\n\n  openList.push(start);\n\n  while (!found && openList.length) {\n    //get the node with the lowest f score from the open list\n    openList.sort((a, b) => nodes[a.r][a.c].f - nodes[b.r][b.c].f);\n    let coord = openList.shift()!;\n    let current = nodes[coord.r][coord.c];\n    if(compareNodes(current, end)){\n      found = true;\n      break;\n    }\n    orderOfVisit.push({r: current.r, c: current.c});\n    closedList.push(current);\n\n    //analyze the neighbours\n    let adjs = getAdjNodes(grid, current);\n    for(const neigbor of adjs){\n      //check if is in the closed set\n      if(closedList.some(el => compareNodes(el, neigbor))){\n        continue;\n      }\n      let tentative_g_score = current.g + 1; // the dist between one node to the neighbor is always 1 since it is a grid\n      if(!openList.some(el => compareNodes(el, neigbor)) || tentative_g_score < nodes[neigbor.r][neigbor.c].g){\n        nodes[neigbor.r][neigbor.c].parent = current;\n        nodes[neigbor.r][neigbor.c].g = tentative_g_score;\n        nodes[neigbor.r][neigbor.c].f = nodes[neigbor.r][neigbor.c].g + calculateHeuristic(euristic, neigbor, end);\n        if(!openList.some(el => compareNodes(el, neigbor))){\n          openList.push(neigbor);\n        }\n      }\n    }\n  }\n\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n  let current = end;\n  var shortestPath = Array<Coordinate>();\n  while (current.r != start.r || current.c != start.c) {\n    shortestPath.push(current);\n    current = nodes[current.r][current.c].parent!;\n  }\n  shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n\ninterface AStarNode {\n  r: number;\n  c: number;\n  f: number;\n  g: number;\n  h: number;\n  parent: Coordinate | null;\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport { Grid } from \"./components/Grid/Grid.component\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}