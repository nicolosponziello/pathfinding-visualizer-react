{"version":3,"sources":["components/Node/node_data.ts","constants.ts","components/Node/node.component.tsx","utils/index.ts","algorithms/common.ts","algorithms/astar-heuristics.ts","components/Header/header.component.tsx","components/Grid/Grid.component.tsx","algorithms/dfs.ts","algorithms/dijkstra.ts","algorithms/bfs.ts","algorithms/astar.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["CellType","GRID_WIDTH","window","innerWidth","GRID_HEIGHT","innerHeight","H_CELLS_NUM","V_CELLS_NUM","Node","props","cssClass","type","EMPTY","START","END","WALL","VISITED","SHORTEST_PATH","onMouseDown","mouseDown","onMouseEnter","mouseEnter","onMouseLeave","mouseLeave","onMouseUp","mouseUp","className","style","width","height","randomInteger","min","max","Math","floor","random","gridDirections","r","c","getAdjNodes","grid","element","adj","Array","push","length","filter","n","compareNodes","a","b","Euristic","Header","useState","wallNum","setWallNum","algoSelected","setAlgo","euristic","setEuristic","value","onChange","ev","parseInt","target","onClick","randomWalls","disabled","onStart","hidden","selected","resetAnimation","resetAll","calculateHeuristic","start","end","DIAGONAL","abs","diagonal","EUCLIDEAN","sqrt","pow","euclidean","MANHATTAN","manhattan","Grid","i","el","j","row","col","generateEmptyGrid","setGrid","startCoord","setStartCoord","endCoord","setEndCoord","isDraggingStart","setIsDraggingStart","isDraggingEnd","setIsDraggingEnd","isDraggingWall","setIsDraggingWall","isAnimating","setIsAnimating","g","produce","copy","algo","res","orderOfVisit","shortestPath","stack","visited","parents","found","tmp","currentNode","pop","some","adjs","reverse","iterativeDFS","nodesToVisit","orderOfExamination","dist","tmp2","Infinity","sort","closest","shift","neighbours","candidate","neighbor","dijkstra","current","queue","tmpDist","tmpVis","console","log","BFS","openList","closedList","nodes","f","h","parent","coord","neigbor","tentative_g_score","AStar","e","getEuristicType","toAnimate","setTimeout","animateResult","amount","randX","randY","display","gridTemplateColumns","toFixed","map","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f7da54b9.chunk.js","sourcesContent":["export type GridNode = {\n  row: number;\n  col: number;\n  type: CellType;\n};\n\nexport enum CellType {\n  WALL,\n  EMPTY,\n  START,\n  END,\n  VISITED,\n  SHORTEST_PATH,\n}\n\nexport type Coordinate = {\n  r: number;\n  c: number;\n};\n\nexport type AlgorithmResult = {\n  orderOfVisit: Array<Coordinate>;\n  shortestPath: Array<Coordinate>;\n};","export const SQUARE_WIDTH = 30;\nexport const SQUARE_HEIGHT = 30;\n\nexport const GRID_WIDTH = window.innerWidth * 0.9;\nexport const GRID_HEIGHT = window.innerHeight * 0.7;\n\nexport const H_CELLS_NUM = GRID_WIDTH / SQUARE_WIDTH;\nexport const V_CELLS_NUM = GRID_HEIGHT / SQUARE_HEIGHT;\n","import React from \"react\";\nimport { SQUARE_WIDTH, SQUARE_HEIGHT } from \"../../constants\";\nimport \"./node.styles.css\";\nimport { CellType } from \"./node_data\";\ninterface Props {\n  row: number;\n  col: number;\n  type: CellType;\n  mouseDown: Function;\n  mouseEnter: Function;\n  mouseLeave: Function;\n  mouseUp: Function;\n}\n\nconst Node = (props: Props) => {\n  var cssClass = \"\";\n  switch (props.type) {\n    case CellType.EMPTY:\n      cssClass = \"empty\";\n      break;\n    case CellType.START:\n      cssClass = \"start\";\n      break;\n    case CellType.END:\n      cssClass = \"end\";\n      break;\n    case CellType.WALL:\n      cssClass = \"wall\";\n      break;\n    case CellType.VISITED:\n      cssClass = \"visited\";\n      break;\n    case CellType.SHORTEST_PATH:\n      cssClass = \"shortestPath\";\n      break;\n  }\n  return (\n    <div\n      onMouseDown={() => props.mouseDown()}\n      onMouseEnter={() => props.mouseEnter()}\n      onMouseLeave={() => props.mouseLeave()}\n      onMouseUp={() => props.mouseUp()}\n      className={`node ${cssClass}`}\n      style={{\n        width: SQUARE_WIDTH,\n        height: SQUARE_HEIGHT,\n      }}\n    />\n  );\n};\n\nexport default Node;\n","export function randomInteger(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function randomEnum<T>(en: T): T[keyof T] {\n  let values = (Object.keys(en)\n    .map((n) => Number.parseInt(n))\n    .filter((n) => !Number.isNaN(n)) as unknown) as T[keyof T][];\n  let randomIndex = randomInteger(0, values.length);\n  return values[randomIndex];\n}\n\nexport const gridDirections = [\n  { r: +1, c: 0 }, //bottom\n  { r: -1, c: 0 }, //top\n  { r: 0, c: -1 }, //left\n  { r: 0, c: +1 }, //right\n];","import { CellType, Coordinate, GridNode } from \"../components/Node/node_data\";\n\nexport function getAdjNodes(\n  grid: Array<Array<GridNode>>,\n  element: Coordinate\n): Array<Coordinate> {\n  var adj = Array<Coordinate>();\n\n  if (element.r > 0) adj.push({ r: element.r - 1, c: element.c });\n  if (element.r + 1 < grid.length) adj.push({ r: element.r + 1, c: element.c });\n  if (element.c > 0) adj.push({ r: element.r, c: element.c - 1 });\n  if (element.c + 1 < grid[0].length)\n    adj.push({ r: element.r, c: element.c + 1 });\n\n  return adj.filter((n) => grid[n.r][n.c].type != CellType.WALL);\n  //.sort(() => Math.random() - 0.5);\n}\n\n\nexport const compareNodes = (a: Coordinate, b: Coordinate): boolean => {\n  return a.r === b.r && a.c === b.c;\n};","import { Coordinate } from \"../components/Node/node_data\";\n\nconst euclidean = (start: Coordinate, end: Coordinate): number => {\n  return Math.sqrt(Math.pow(start.r + end.r, 2) + Math.pow(start.c + end.c, 2));\n};\n\nconst diagonal = (start: Coordinate, end: Coordinate): number => {\n  return Math.max(Math.abs(start.r - end.r), Math.abs(start.c - end.c));\n};\n\nconst manhattan = (start: Coordinate, end: Coordinate): number => {\n  return Math.abs(start.r - end.r) + Math.abs(start.c - end.c);\n};\n\nexport enum Euristic {\n  EUCLIDEAN,\n  MANHATTAN,\n  DIAGONAL,\n}\n\nexport const calculateHeuristic = (\n  type: Euristic,\n  start: Coordinate,\n  end: Coordinate\n): number => {\n  switch (type) {\n    case Euristic.DIAGONAL:\n      return diagonal(start, end);\n    case Euristic.EUCLIDEAN:\n      return euclidean(start, end);\n    case Euristic.MANHATTAN:\n      return manhattan(start, end);\n  }\n};\n","import React, { useState } from \"react\";\nimport \"./header.styles.css\";\ninterface Props {\n  onStart: Function;\n  randomWalls: Function;\n  resetAnimation: () => void;\n  resetAll: () => void;\n}\n\nconst Header = (props: Props) => {\n  const [wallNum, setWallNum] = useState(10);\n  const [algoSelected, setAlgo] = useState(\"\");\n  const [euristic, setEuristic] = useState(\"manhattan\");\n  return (\n    <>\n      <div className=\"header-bar\">\n        <span className=\"app-name\">Algorithm Pathfinding</span>\n        <label>\n          <span className=\"selector-label\">Walls: </span>\n          <input\n            className=\"input\"\n            value={wallNum}\n            type=\"number\"\n            onChange={(ev) => setWallNum(parseInt(ev.target.value))}\n          />\n        </label>\n        <button className=\"button\" onClick={() => props.randomWalls(wallNum)}>\n          Generate Walls\n        </button>\n        <button\n          disabled={algoSelected === \"\"}\n          className=\"button start-btn\"\n          onClick={() => props.onStart(algoSelected, euristic)}\n        >\n          START\n        </button>\n        <div>\n          <span className=\"selector-label\">Algorithm: </span>\n          <select\n            className=\"select\"\n            onChange={(ev) => setAlgo(ev.target.value)}\n          >\n            <option hidden disabled selected>\n              ---\n            </option>\n            <option value=\"dfs\">DFS</option>\n            <option value=\"bfs\">BFS</option>\n            <option value=\"dijkstra\">Dijkstra</option>\n            <option value=\"a*\">A*</option>\n          </select>\n\n          <select\n            disabled={algoSelected != \"a*\"}\n            className=\"select\"\n            onChange={(ev) => setEuristic(ev.target.value)}\n          >\n            <option value=\"manhattan\">MANHATTAN</option>\n            <option value=\"euclidean\">EUCLIDEAN</option>\n            <option value=\"diagonal\">DIAGONAL</option>\n          </select>\n        </div>\n        <button className=\"button\" onClick={props.resetAnimation}>\n          Reset Animation\n        </button>\n        <button className=\"button\" onClick={props.resetAll}>\n          Reset All\n        </button>\n      </div>\n    </>\n  );\n};\n\nexport default Header;\n","import React, { useState } from \"react\";\nimport { H_CELLS_NUM, SQUARE_WIDTH, V_CELLS_NUM } from \"../../constants\";\nimport Node from \"../Node/node.component\";\nimport { produce } from \"immer\";\nimport {\n  GridNode,\n  CellType,\n  Coordinate,\n  AlgorithmResult,\n} from \"../Node/node_data\";\nimport dijkstra from \"../../algorithms/dijkstra\";\nimport  {iterativeDFS} from \"../../algorithms/dfs\";\nimport { randomInteger } from \"../../utils\";\nimport BFS from \"../../algorithms/bfs\";\n\nimport \"./grid.style.css\";\nimport Header from \"../Header/header.component\";\nimport AStar from \"../../algorithms/astar\";\nimport { Euristic } from \"../../algorithms/astar-heuristics\";\n\ninterface Props {}\n\nconst getEuristicType = (e: string | undefined): Euristic => {\n  switch (e) {\n    case \"manhattan\":\n      return Euristic.MANHATTAN;\n    case \"diagonal\":\n      return Euristic.DIAGONAL;\n    case \"euclidean\":\n      return Euristic.EUCLIDEAN;\n  }\n  return Euristic.MANHATTAN;\n};\n\nconst generateEmptyGrid = () => {\n  var grid = Array<Array<GridNode>>();\n  for (var i = 0; i < V_CELLS_NUM; i++) {\n    var el = Array<GridNode>();\n    for (var j = 0; j < H_CELLS_NUM; j++) {\n      el.push({\n        row: i,\n        col: j,\n        type: CellType.EMPTY,\n      });\n    }\n    grid.push(el);\n  }\n  //set start and end\n  grid[5][5].type = CellType.START;\n  grid[grid.length - 5][grid[0].length - 5].type = CellType.END;\n  return grid;\n};\n\n\nexport const Grid = (props: Props) => {\n  const [grid, setGrid] = useState(() => {\n    return generateEmptyGrid();\n  });\n  const [startCoord, setStartCoord] = useState({ r: 5, c: 5 });\n  const [endCoord, setEndCoord] = useState({\n    r: grid.length - 5,\n    c: grid[0].length - 5,\n  });\n  const [isDraggingStart, setIsDraggingStart] = useState(false);\n  const [isDraggingEnd, setIsDraggingEnd] = useState(false);\n  const [isDraggingWall, setIsDraggingWall] = useState(false);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  const resetAll = () => {\n    setGrid((g) => {\n      return produce(g, (copy) => {\n        for (var i = 0; i < copy.length; i++) {\n          for (var j = 0; j < copy[0].length; j++) {\n            if (\n              copy[i][j].type === CellType.SHORTEST_PATH ||\n              copy[i][j].type === CellType.VISITED ||\n              copy[i][j].type === CellType.WALL\n            )\n              copy[i][j].type = CellType.EMPTY;\n          }\n        }\n      });\n    });\n  };\n\n  const animateResult = (res: AlgorithmResult) => {\n    //animate visited\n    for(let i = 0; i < res.orderOfVisit.length; i++){\n      let toAnimate = res.orderOfVisit[i];\n      if (!toAnimate) {\n        return;\n      }\n      setTimeout( () => {\n        setGrid((g) => {\n          return produce(g, (copy) => {\n            if (\n              copy[toAnimate.r][toAnimate.c].type != CellType.END &&\n              copy[toAnimate.r][toAnimate.c].type != CellType.START\n            ) {\n              copy[toAnimate.r][toAnimate.c].type = CellType.VISITED;\n            }\n          });\n        });\n     }, 100);\n    }\n\n    //animate shortest path\n    for(let i = 0; i < res.shortestPath.length; i++){\n      let toAnimate = res.shortestPath[i];\n      if (!toAnimate) return;\n      setTimeout(() => {\n        setGrid((g) => {\n          return produce(g, (copy) => {\n            if (\n              copy[toAnimate.r][toAnimate.c].type != CellType.END &&\n              copy[toAnimate.r][toAnimate.c].type != CellType.START\n            ) {\n              copy[toAnimate.r][toAnimate.c].type = CellType.SHORTEST_PATH;\n            }\n          });\n        });\n      }, 100);\n    }\n  };\n\n  const start = (algo: string, euristic: string | undefined) => {\n    resetAnimation();\n    setIsAnimating(true);\n    var res: AlgorithmResult = { orderOfVisit: [], shortestPath: [] };\n    switch (algo) {\n      case \"dfs\":\n        res = iterativeDFS(grid, startCoord, endCoord);\n        break;\n      case \"dijkstra\":\n        res = dijkstra(grid, startCoord, endCoord);\n        break;\n      case \"bfs\":\n        res = BFS(grid, startCoord, endCoord);\n        break;\n      case \"a*\":\n        res = AStar(grid, startCoord, endCoord, getEuristicType(euristic));\n    }\n    animateResult(res);\n    setIsAnimating(false);\n  };\n\n  const resetAnimation = () => {\n    setGrid((g) => {\n      return produce(g, (copy) => {\n        for (var i = 0; i < copy.length; i++) {\n          for (var j = 0; j < copy[0].length; j++) {\n            if (\n              copy[i][j].type === CellType.SHORTEST_PATH ||\n              copy[i][j].type === CellType.VISITED\n            )\n              copy[i][j].type = CellType.EMPTY;\n          }\n        }\n      });\n    });\n  };\n\n  const addRandomWalls = (amount: number): void => {\n    setGrid(g => {\n      return produce(g, copy => {\n        let randX, randY;\n        for (let i = 0; i < amount; i++) {\n          do {\n            randX = randomInteger(0, grid.length - 1);\n            randY = randomInteger(0, grid[0].length - 1);\n          } while (copy[randX][randY].type != CellType.EMPTY);\n          copy[randX][randY].type = CellType.WALL;\n        }\n      });\n    });\n  };\n  \n\n  return (\n    <>\n      <Header \n        onStart={start}\n        resetAnimation={resetAnimation}\n        resetAll={resetAll}\n        randomWalls={addRandomWalls}\n      />     \n      \n      <div className=\"container\">\n        <div\n          className=\"grid\"\n          style={{\n            display: \"grid\",\n            gridTemplateColumns: `repeat(${H_CELLS_NUM.toFixed(\n              0\n            )}, ${SQUARE_WIDTH}px)`,\n          }}\n        >\n          {grid.map((row, i) => {\n            return row.map((col, j) => {\n              return (\n                <Node\n                  key={`${i}-${j}`}\n                  row={i}\n                  col={j}\n                  type={col.type}\n                  mouseDown={() => {\n                    if (!isAnimating) {\n                      if (col.type === CellType.START) {\n                        setIsDraggingStart(true);\n                      } else if (col.type == CellType.END) {\n                        setIsDraggingEnd(true);\n                      } else {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            if (copy[i][j].type === CellType.EMPTY) {\n                              copy[i][j].type = CellType.WALL;\n                            } else if (copy[i][j].type === CellType.WALL) {\n                              copy[i][j].type = CellType.EMPTY;\n                            }\n                          });\n                        });\n                        setIsDraggingWall(true);\n                      }\n                    }\n                  }}\n                  mouseEnter={() => {\n                    if (!isAnimating) {\n                      if (isDraggingStart) {\n                        setStartCoord({ r: i, c: j });\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            copy[i][j].type = CellType.START;\n                          });\n                        });\n                      } else if (isDraggingEnd) {\n                        setEndCoord({ r: i, c: j });\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            copy[i][j].type = CellType.END;\n                          });\n                        });\n                      } else if (isDraggingWall) {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            if (copy[i][j].type === CellType.EMPTY) {\n                              copy[i][j].type = CellType.WALL;\n                            } else if (copy[i][j].type === CellType.WALL) {\n                              copy[i][j].type = CellType.EMPTY;\n                            }\n                          });\n                        });\n                      }\n                    }\n                  }}\n                  mouseLeave={() => {\n                    if (!isAnimating) {\n                      if (isDraggingStart || isDraggingEnd) {\n                        setGrid((g) => {\n                          return produce(g, (copy) => {\n                            copy[i][j].type = CellType.EMPTY;\n                          });\n                        });\n                      }\n                    }\n                  }}\n                  mouseUp={() => {\n                    setIsDraggingStart(false);\n                    setIsDraggingEnd(false);\n                    setIsDraggingWall(false);\n                  }}\n                />\n              );\n            });\n          })}\n        </div>\n      </div>\n    </>\n  );\n};\n","import {\n  GridNode,\n  Coordinate,\n  AlgorithmResult,\n  CellType,\n} from \"../components/Node/node_data\";\nimport { getAdjNodes } from \"./common\";\n\nexport function iterativeDFS(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var stack = Array<Coordinate>(); //stack of visited nodes\n  var visited = Array<Coordinate>();\n  var orderOfVisit = Array<Coordinate>();\n  var parents = Array<Array<Coordinate>>();\n  var found = false;\n\n  //init parents matrix\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = Array<Coordinate>();\n    for (let j = 0; j < grid[0].length; j++) {\n      tmp.push({ r: -1, c: -1 });\n    }\n    parents.push(tmp);\n  }\n\n  var currentNode = { r: start.r, c: start.c };\n  stack.push(currentNode);\n  while (!found && stack.length) {\n    currentNode = stack.pop()!;\n    //if the node is not visited\n    orderOfVisit.push(currentNode);\n    if (!visited.some((n) => n.r === currentNode.r && n.c === currentNode.c)) {\n      visited.push(currentNode);\n    }\n    let adjs = getAdjNodes(grid, currentNode);\n    for (let i = 0; i < adjs.length; i++) {\n      if (!visited.some((n) => n.r === adjs[i].r && n.c === adjs[i].c)) {\n        parents[adjs[i].r][adjs[i].c] = currentNode;\n        stack.push(adjs[i]);\n      }\n    }\n    if (currentNode.r === end.r && currentNode.c === end.c) {\n      found = true;\n    }\n  }\n\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n\n  var shortestPath = Array<Coordinate>();\n  //build shortest path array\n  currentNode = end;\n  while (currentNode.r != start.r || currentNode.c != start.c) {\n    shortestPath.push(currentNode);\n    currentNode = parents[currentNode.r][currentNode.c];\n  }\n  shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n","import { AlgorithmResult, CellType, Coordinate, GridNode } from \"../components/Node/node_data\";\nimport { gridDirections } from \"../utils\";\n\nexport default function dijkstra(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var nodesToVisit = Array<Coordinate>();\n  var shortestPath = Array<Coordinate>();\n  var orderOfExamination = Array<Coordinate>();\n  var discoveredNodes = Array<Coordinate>();\n  var parents = Array<Array<Coordinate>>();\n  var dist = Array<Array<number>>();\n  var found = false;\n\n  //initialize dist matrix\n  for (var i = 0; i < grid.length; i++) {\n    var tmp = Array<number>();\n    var tmp2 = Array<Coordinate>();\n    for (var j = 0; j < grid[0].length; j++) {\n      tmp2.push({ r: -1, c: -1 });\n      tmp.push(Infinity);\n    }\n    parents.push(tmp2);\n    dist.push(tmp);\n  }\n  parents[start.r][start.c] = { r: 0, c: 0 };\n  dist[start.r][start.c] = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      nodesToVisit.push({ r: grid[i][j].row, c: grid[i][j].col });\n    }\n  }\n\n  var currentNode: Coordinate = { r: start.r, c: start.c };\n  while (!found && nodesToVisit.length) {\n    //sort remaining nodes by distance\n    nodesToVisit.sort((a, b) => dist[a.r][a.c] - dist[b.r][b.c]);\n    const closest = nodesToVisit.shift()!;\n\n    //hit a wall\n    if (grid[closest?.r][closest?.c].type === CellType.WALL) {\n      continue;\n    }\n\n    //trapped\n    if (dist[closest.r][closest.c] === Infinity) {\n      return {\n        orderOfVisit: orderOfExamination,\n        shortestPath: [],\n      };\n    }\n\n    //all good\n    //register visit\n    orderOfExamination.push(closest);\n    //did we find the end?\n    if (closest.r === end.r && closest.c === end.c) {\n      found = true;\n    }\n\n    //get available neighbours\n    let neighbours = [];\n    for (let i = 0; i < gridDirections.length; i++) {\n      let candidate = {       \n        r: closest.r + gridDirections[i].r,\n        c: closest.c + gridDirections[i].c,\n      };\n      if(        \n        candidate.r >= 0 &&\n        candidate.r < grid.length &&\n        candidate.c >= 0 &&\n        candidate.c < grid[0].length &&\n        !orderOfExamination.some(n => n.r === candidate.r && n.c === candidate.c)) {\n          neighbours.push(candidate);\n      }\n    }\n\n    //iterate the neighbours\n    for (const neighbor of neighbours) {\n      dist[neighbor.r][neighbor.c] = dist[closest.r][closest.c] + 1;\n      parents[neighbor.r][neighbor.c] = closest;\n    }\n\n  }\n  //calculate shortest path from end to start\n  currentNode.c = end.c;\n  currentNode.r = end.r;\n  while       (currentNode.c != start.c || currentNode.r != start.r)       {\n    shortestPath.push(currentNode);\n    currentNode = parents[currentNode.r][currentNode.c];\n  }\n  shortestPath = shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfExamination,\n    shortestPath: shortestPath,\n  };\n}","import {\n  AlgorithmResult,\n  Coordinate,\n  GridNode,\n} from \"../components/Node/node_data\";\nimport { getAdjNodes } from \"./common\";\n\nexport default function BFS(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate\n): AlgorithmResult {\n  var queue = Array<Coordinate>();\n  var orderOfVisit = Array<Coordinate>();\n  var dist = Array<Array<number>>();\n  var parents = Array<Array<Coordinate>>();\n  var visited = Array<Array<boolean>>();\n  var current;\n  var found = false;\n\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = Array<Coordinate>();\n    let tmpDist = Array<number>();\n    let tmpVis = Array<boolean>();\n    for (let j = 0; j < grid[0].length; j++) {\n      tmp.push({ r: -1, c: -1 });\n      tmpDist.push(Infinity);\n      tmpVis.push(false);\n    }\n    parents.push(tmp);\n    dist.push(tmpDist);\n    visited.push(tmpVis);\n  }\n\n  dist[start.r][start.c] = 0;\n  visited[start.r][start.c] = true;\n  queue.push(start);\n\n  while (!found && queue.length) {\n    current = queue.shift()!;\n    visited[current.r][current.c] = true;\n    if (current.r === end.r && current.c === end.c) {\n      found = true;\n    }\n    orderOfVisit.push(current);\n    let neighbours = getAdjNodes(grid, current);\n    for (const neighbor of neighbours) {\n      //if not visited yet\n      if (!visited[neighbor.r][neighbor.c]) {\n        dist[neighbor.r][neighbor.c] = dist[current.r][current.c] + 1;\n        parents[neighbor.r][neighbor.c] = current;\n        visited[neighbor.r][neighbor.c] = true;\n        queue.push(neighbor);\n\n        if (neighbor.r === end.r && neighbor.c === end.c) {\n          found = true;\n        }\n      }\n    }\n  }\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n\n  current = end;\n  var shortestPath = Array<Coordinate>();\n  while (current.r != start.r || current.c != start.c) {\n    shortestPath.push(current);\n    current = parents[current.r][current.c];\n  }\n  shortestPath.reverse();\n  console.log(\"bfs completed\");\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n","import {\n  AlgorithmResult,\n  Coordinate,\n  GridNode,\n} from \"../components/Node/node_data\";\nimport { calculateHeuristic, Euristic } from \"./astar-heuristics\";\nimport { compareNodes, getAdjNodes } from \"./common\";\n\nexport default function AStar(\n  grid: Array<Array<GridNode>>,\n  start: Coordinate,\n  end: Coordinate,\n  euristic: Euristic\n): AlgorithmResult {\n  var orderOfVisit = Array<Coordinate>();\n  var openList = Array<Coordinate>();\n  var closedList = Array<Coordinate>();\n  var found = false;\n  let nodes = Array<Array<AStarNode>>();\n  let dist = Array<Array<number>>();\n\n  //init nodes matrix\n  for (let i = 0; i < grid.length; i++) {\n    let tmp = [];\n    let tmpDist = [];\n    for (let j = 0; j < grid[0].length; j++) {\n      tmpDist.push(Infinity);\n      tmp.push({\n        r: i,\n        c: j,\n        g: Infinity,\n        f: Infinity,\n        h: Infinity,\n        parent: null,\n      });\n    }\n    nodes.push(tmp);\n    dist.push(tmpDist);\n  }\n  \n  dist[start.r][start.c] = 0;\n\n  nodes[start.r][start.c].g = 0;\n  nodes[start.r][start.c].h = calculateHeuristic(euristic, start, end);\n  nodes[start.r][start.c].f = nodes[start.r][start.c].g + nodes[start.r][start.c].h;\n\n  openList.push(start);\n\n  while (!found && openList.length) {\n    //get the node with the lowest f score from the open list\n    openList.sort((a, b) => nodes[a.r][a.c].f - nodes[b.r][b.c].f);\n    let coord = openList.shift()!;\n    let current = nodes[coord.r][coord.c];\n    if(compareNodes(current, end)){\n      found = true;\n      break;\n    }\n    orderOfVisit.push({r: current.r, c: current.c});\n    closedList.push(current);\n\n    //analyze the neighbours\n    let adjs = getAdjNodes(grid, current);\n    for(const neigbor of adjs){\n      //check if is in the closed set\n      if(closedList.some(el => compareNodes(el, neigbor))){\n        continue;\n      }\n      let tentative_g_score = current.g + 1; // the dist between one node to the neighbor is always 1 since it is a grid\n      if(!openList.some(el => compareNodes(el, neigbor)) || tentative_g_score < nodes[neigbor.r][neigbor.c].g){\n        nodes[neigbor.r][neigbor.c].parent = current;\n        nodes[neigbor.r][neigbor.c].g = tentative_g_score;\n        nodes[neigbor.r][neigbor.c].f = nodes[neigbor.r][neigbor.c].g + calculateHeuristic(euristic, neigbor, end);\n        if(!openList.some(el => compareNodes(el, neigbor))){\n          openList.push(neigbor);\n        }\n      }\n    }\n  }\n\n  if (!found) {\n    return {\n      orderOfVisit: orderOfVisit,\n      shortestPath: [],\n    };\n  }\n  let current = end;\n  var shortestPath = Array<Coordinate>();\n  while (current.r != start.r || current.c != start.c) {\n    shortestPath.push(current);\n    current = nodes[current.r][current.c].parent!;\n  }\n  shortestPath.reverse();\n  return {\n    orderOfVisit: orderOfVisit,\n    shortestPath: shortestPath,\n  };\n}\n\ninterface AStarNode {\n  r: number;\n  c: number;\n  f: number;\n  g: number;\n  h: number;\n  parent: Coordinate | null;\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport { Grid } from \"./components/Grid/Grid.component\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}